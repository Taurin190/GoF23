# GoF23
デザインパターン入門

## 1.Iteratorパターン
要素を一つずつ取り出すパターン。
数える対象のオブジェクトを知らなくても取り出しや数え上げることが出来るため、
取り出す側のクラスが取り出せるクラスに依存せずに扱える。

## 2.Adapter
外部呼び出しの新規インタフェースを既存のクラスを変更せずに適応させるパターン。
既存のクラスを活かす方法として、追加のメソッドを生やす方法も考えられる。

しかし、２つ目のクラスのために拡張する分に良くとも３つ、４つと増えると無駄に同じような関数が増えてしまう。
そのため、外部インタフェースに対応するAdapterクラスを用意する。

## 3.TemplateMethod
その名の通りabstractクラスやinterfaceクラスで同様のクラスのインタフェースを揃えるパターン。
同じような処理を行っている部分は同じ関数名に合わせ、abstractメソッドの場合は共通処理をまとめる。
必要な部分のみ子クラスで実装する。

## 4.FactoryMethod
何かを生産するFactoryを使用してインスタンスを作るパターン。
同様のインスタンスをユーザ毎に割り当てて管理する場合などに使える。

また、コンストラクタは対象のクラスの新しいインスタンスを返すものであるため、
より柔軟に引数により異なるインスタンスを返したり、
ドメインの境界クラスなど組み立て方の決まったクラスの組み立てて生成するためにも使える。

## 5.Singleton
インスタンスをただ一つのみ生成するパターン。
最初の一回はインスタンスを生成して二回目以降は生成済みのインスタンスを返す。
複数のインスタンスを生成して整合性が取れなくなることを防ぐ。

## 6.Prototype

## 7.Builder
インスタンスの組み立てを他のインスタンスに移譲するパターン。
呼び出し側ではどのように組み立てるかということを考えなくてもビルダーに渡して、
生成して結果を得ることが出来る。

## 8.AbstractFactory
Factoryパターンと同様に組み立てた生成物など単純にインスタンスを返す場合でない、
インスタンス生成を行えるパターン。
パーツを加えるのはコストがかかるが組み立てるFactoryを追加は簡単に行えうるので、
htmlを出力などパーツは決まっていていくつかのバリエーションで組み立てが必要な場合に
使うことが出来るパターン。

## 9.Bridge
抽象クラスと実装クラス、機能拡張して親クラスと子クラスの両方を繋ぐパターン。

## 10.Strategy
戦術クラスを切り分けて切り替えを可能にするパターン。

## 11.Composite
複数のタイプを同様に扱い、複数のコンポーネントを内包し入れ子に出来る仕組みも持ち、
木構造のようなクラスの扱いを出来るようにする。
Unixのファイルシステムや木構造などを表現するのに有効なパターン。

## 12.Decorator
出力の装飾を行うパターン。文字列に線を付けたり、htmlの文章に変換するときなどに使える。
例えば、helloという文字列を入力して\<p>hello\</p>と出力するような事を行う。

## 13.Visitor
木構造などの構造を辿り処理を行うパターンで、iteratorやポインタとも似ている。

## 14.ChainOfResponsibility
処理のたらい回しを行うパターン。
処理を行う判断を行い、行わない場合には次に回す。
宣言時にもチェーン状に繋げて実行を開始する。

## 15.Facade
入り口を絞って処理する場所を限定するパターン。
Controllerにルート後の処理を渡し、View, Modelに直接触らないMVCパターンも
このパターン。

## 16.Mediator

## 17.Observer
変更が非同期的に行われる、複数のクラスから変更が加わるクラスの変更を観察して、
変更時に特定の処理を行うパターン。

## 18.Memento
インスタンスに状態を保存するパターン。
ゲームなどのセーブのように各種情報をメモリ上に留めて状態を復帰できるようにする。

## 19.State

## 20.Memento

## 21.Proxy

## 22.Command

## 23.Interpreter